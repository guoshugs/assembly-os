     1                                           ;在保护模式下对字符串进行排序的程序
     2                                           ;计算GDT所在的逻辑段地址
     3 00000000 2E66A1[417D]                     mov eax,[cs:pgdt+0x7c00+0x02]      ;GDT的32位线性基地址 
     4 00000005 6631D2                           xor edx,edx
     5 00000008 66BB10000000                     mov ebx,16
     6 0000000E 66F7F3                           div ebx                            ;分解成16位逻辑地址 
     7                                  
     8 00000011 8ED8                             mov ds,eax                         ;令DS指向该段以进行操作
     9 00000013 6689D3                           mov ebx,edx                        ;段内起始偏移地址 
    10                                  
    11                                           ;创建0#描述符，它是空描述符，这是处理器的要求
    12 00000016 6667C70300000000                 mov dword [ebx+0x00],0x00000000
    13 0000001E 6667C7430400000000               mov dword [ebx+0x04],0x00000000  
    14                                  
    15                                           ;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间
    16 00000027 6667C74308FFFF0000               mov dword [ebx+0x08],0x0000ffff    ;基地址为0x00000000，向上扩展
    17 00000030 6667C7430C0092CF00               mov dword [ebx+0x0c],0x00cf9200    ;段界限为0xfffff，段界限的粒度以4KB为单位，因此实际使用的界限值是ffffffff，数据段描述符 
    18                                  
    19                                           ;创建保护模式下初始代码段描述符
    20 00000039 6667C74310FF01007C               mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 
    21 00000042 6667C7431400984000               mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 
    22                                  
    23                                           ;创建以上代码段的别名描述符，将x位设置成1
    24 0000004B 6667C74318FF01007C               mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节
    25 00000054 6667C7431C00924000               mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符
    26                                           
    27                                           ;创建数据段描述符，实际用做栈段
    28 0000005D 6667C74320FF07006C               mov dword [ebx+0x20],0x6c0007ff    ;基地址为0x00006c00，向上扩展，512字节
    29 00000066 6667C7432400924000               mov dword [ebx+0x24],0x00409200    ;界限为0x007ff，粒度为1个字节，数据段描述符
    30                                           
    31                                           ;初始化描述符表寄存器GDTR
    32 0000006F 2EC706[3F7D]2700                 mov word [cs: pgdt+0x7c00],39      ;描述符表的界限5*8-1，此时就将初始化为0的pgdt位置改成39
    33                                   
    34 00000076 2E0F0116[3F7D]                   lgdt [cs: pgdt+0x7c00]             ;全局描述符表的尺寸有了，就可以load加载了
    35                                        
    36 0000007C E492                             in al,0x92                         ;南桥芯片内的端口 
    37 0000007E 0C02                             or al,0000_0010B
    38 00000080 E692                             out 0x92,al                        ;打开A20
    39                                  
    40 00000082 FA                               cli                                ;中断机制尚未工作
    41                                  
    42 00000083 0F20C0                           mov eax,cr0
    43 00000086 6683C801                         or eax,1
    44 0000008A 0F22C0                           mov cr0,eax                        ;设置PE位
    45                                        
    46                                           ;以下进入保护模式... ...0000000000010_0_00B
    47 0000008D EA[9200]1000                     jmp 0x0010:flush                   ;这条指令会修改段寄存器cs，16位的描述符选择子：32位偏移
    48                                                                              ;用一个D位是1的描述符刷新了段寄存器CS，就选择了32位
    49                                           [bits 32]                          
    50                                    flush:                                     
    51 00000092 B808000000                       mov eax,0x0008                     ;因为是在保护模式下，所以0008是段选择子0000000000001_0_00B
    52 00000097 8EC0                             mov es,eax                         ;es设置到4GB数据段，这些选择子的TI位都是0，加载数据段选择子
    53 00000099 8EE0                             mov fs,eax                         ;可省略，程序内未使用FS
    54 0000009B 8EE8                             mov gs,eax                         ;可省略，程序内未使用GS
    55                                           
    56 0000009D 26C70500800B005007-              mov dword [es:0x0b8000],0x072e0750 ;字符'P'、'.'及其显示属性
    56 000000A6 2E07               
    57 000000A8 26C70504800B004D07-              mov dword [es:0x0b8004],0x072e074d ;字符'M'、'.'及其显示属性
    57 000000B1 2E07               
    58 000000B3 26C70508800B002007-              mov dword [es:0x0b8008],0x07200720 ;两个空白字符及其显示属性
    58 000000BC 2007               
    59 000000BE 26C7050C800B006F07-              mov dword [es:0x0b800c],0x076b076f ;字符'o'、'k'及其显示属性
    59 000000C7 6B07               
    60                                  
    61 000000C9 B818000000                       mov eax,0x0018                     ;0000000000011_0_00B，是3号，第4个描述符
    62 000000CE 8ED8                             mov ds,eax                         ;加载与代码段重叠的数据段选择子
    63                                           
    64 000000D0 B820000000                       mov eax,0x0020                     ;0000 0000 0010 0000，0000000000100_0_00B
    65 000000D5 8ED0                             mov ss,eax                         ;加载栈段选择子
    66 000000D7 BC00080000                       mov esp,0x800                      ;向下扩展的段，应将ESP的值初始化为段的最大界限值+1
    67                                                                              ;向上扩展的段，B位是1因此在执行隐式段操作指令时用esp，应将栈指针设置为段大小800，就是2048
    68                                           ;开始冒泡排序 
    69 000000DC B924000000                       mov ecx,pgdt-string-1              ;遍历次数=串长度-1 
    70                                    @@1:
    71 000000E1 51                               push ecx                           ;32位模式下的loop使用ecx 
    72 000000E2 6631DB                           xor bx,bx                          ;32位模式下，偏移量可以是16位，也可以 
    73                                    @@2:                                      ;是后面的32位 
    74 000000E5 66678B87[1A01]                   mov ax,[string+bx]                 ;从内存中取出一个字，该字包含了两个相邻的字符，bx用来定位串中的每个字符
    75 000000EB 38C4                             cmp ah,al                          ;ah中存放的是源字的高字节。要使用段寄存器dx，使用dx描述符高速缓存器中的基地址7c00+string+bx生成线性地址再取出一个字
    76 000000ED 7D08                             jge @@3 
    77 000000EF 86C4                             xchg al,ah 
    78 000000F1 66678987[1A01]                   mov [string+bx],ax 
    79                                    @@3:
    80 000000F7 6643                             inc bx 
    81 000000F9 E2EA                             loop @@2 
    82 000000FB 59                               pop ecx 
    83 000000FC E2E3                             loop @@1
    84                                        
    85 000000FE B925000000                       mov ecx,pgdt-string
    86 00000103 31DB                             xor ebx,ebx                        ;偏移地址是32位的情况 
    87                                    @@4:                                      ;32位的偏移具有更大的灵活性
    88 00000105 B407                             mov ah,0x07
    89 00000107 8A83[1A010000]                   mov al,[string+ebx]                ;取得字符串中的一个字符，此时在ax中就完整的包含了一个字符的编码和属性
    90 0000010D 266689841BA0800B00               mov [es:0xb80a0+ebx*2],ax          ;向显存中传送，使用段超越前缀es，指向整个4G字节的段，演示0~4GB寻址。
    91 00000116 43                               inc ebx                            ;b80a0定位屏幕第二行，ebx*2用来定位后面每个字符的位置
    92 00000117 E2EC                             loop @@4
    93                                        
    94 00000119 F4                               hlt
    95                                  
    96                                  ;-------------------------------------------------------------------------------
    97 0000011A 73306B65346F723932-          string           db 's0ke4or92xap3fv8giuzjcy5l1m7hd6bnqtw.'    ;任务是对字符串排序按照字符编码的大小，结果显示在屏幕上
    97 00000123 786170336676386769-
    97 0000012C 757A6A6379356C316D-
    97 00000135 37686436626E717477-
    97 0000013E 2E                 
    98                                  ;-------------------------------------------------------------------------------
    99 0000013F 0000                         pgdt             dw 0               ;先定义一个字，是GDT的边界值，初始化为0，需要再程序中加以填充
   100 00000141 007E0000                                      dd 0x00007e00      ;再定义一个双字，指定GDT的线性物理地址，共6个字节
   101                                  ;-------------------------------------------------------------------------------                             
   102 00000145 00<rep B9h>                  times 510-($-$$) db 0
   103 000001FE 55AA                                          db 0x55,0xaa

         ;在保护模式下对字符串进行排序的程序
         ;计算GDT所在的逻辑段地址
         mov eax,[cs:pgdt+0x7c00+0x02]      ;GDT的32位线性基地址 
         xor edx,edx
         mov ebx,16
         div ebx                            ;分解成16位逻辑地址 

         mov ds,eax                         ;令DS指向该段以进行操作
         mov ebx,edx                        ;段内起始偏移地址 

         ;创建0#描述符，它是空描述符，这是处理器的要求
         mov dword [ebx+0x00],0x00000000
         mov dword [ebx+0x04],0x00000000  

         ;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间
         mov dword [ebx+0x08],0x0000ffff    ;基地址为0x00000000，向上扩展
         mov dword [ebx+0x0c],0x00cf9200    ;段界限为0xfffff，段界限的粒度以4KB为单位，因此实际使用的界限值是ffffffff，数据段描述符 

         ;创建保护模式下初始代码段描述符
         mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 
         mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 

         ;创建以上代码段的别名描述符，将x位设置成1
         mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节
         mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符
         
         ;创建数据段描述符，实际用做栈段
         mov dword [ebx+0x20],0x6c0007ff    ;基地址为0x00006c00，向上扩展，512字节
         mov dword [ebx+0x24],0x00409200    ;界限为0x007ff，粒度为1个字节，数据段描述符
         
         ;初始化描述符表寄存器GDTR
         mov word [cs: pgdt+0x7c00],39      ;描述符表的界限5*8-1，此时就将初始化为0的pgdt位置改成39
 
         lgdt [cs: pgdt+0x7c00]             ;全局描述符表的尺寸有了，就可以load加载了
      
         in al,0x92                         ;南桥芯片内的端口 
         or al,0000_0010B
         out 0x92,al                        ;打开A20

         cli                                ;中断机制尚未工作

         mov eax,cr0
         or eax,1
         mov cr0,eax                        ;设置PE位
      
         ;以下进入保护模式... ...0000000000010_0_00B
         jmp 0x0010:flush                   ;这条指令会修改段寄存器cs，16位的描述符选择子：32位偏移
                                            ;用一个D位是1的描述符刷新了段寄存器CS，就选择了32位
         [bits 32]                          
  flush:                                     
         mov eax,0x0008                     ;因为是在保护模式下，所以0008是段选择子0000000000001_0_00B
         mov es,eax                         ;es设置到4GB数据段，这些选择子的TI位都是0，加载数据段选择子
         mov fs,eax                         ;可省略，程序内未使用FS
         mov gs,eax                         ;可省略，程序内未使用GS
         
         mov dword [es:0x0b8000],0x072e0750 ;字符'P'、'.'及其显示属性
         mov dword [es:0x0b8004],0x072e074d ;字符'M'、'.'及其显示属性
         mov dword [es:0x0b8008],0x07200720 ;两个空白字符及其显示属性
         mov dword [es:0x0b800c],0x076b076f ;字符'o'、'k'及其显示属性

         mov eax,0x0018                     ;0000000000011_0_00B，是3号，第4个描述符
         mov ds,eax                         ;加载与代码段重叠的数据段选择子
         
         mov eax,0x0020                     ;0000 0000 0010 0000，0000000000100_0_00B
         mov ss,eax                         ;加载栈段选择子
         mov esp,0x800                      ;向下扩展的段，应将ESP的值初始化为段的最大界限值+1
                                            ;向上扩展的段，B位是1因此在执行隐式段操作指令时用esp，应将栈指针设置为段大小800，就是2048
         ;开始冒泡排序 
         mov ecx,pgdt-string-1              ;遍历次数=串长度-1 
  @@1:
         push ecx                           ;32位模式下的loop使用ecx 
         xor bx,bx                          ;32位模式下，偏移量可以是16位，也可以 
  @@2:                                      ;是后面的32位 
         mov ax,[string+bx]                 ;从内存中取出一个字，该字包含了两个相邻的字符，bx用来定位串中的每个字符
         cmp ah,al                          ;ah中存放的是源字的高字节。要使用段寄存器dx，使用dx描述符高速缓存器中的基地址7c00+string+bx生成线性地址再取出一个字
         jge @@3 
         xchg al,ah 
         mov [string+bx],ax 
  @@3:
         inc bx 
         loop @@2 
         pop ecx 
         loop @@1
      
         mov ecx,pgdt-string
         xor ebx,ebx                        ;偏移地址是32位的情况 
  @@4:                                      ;32位的偏移具有更大的灵活性
         mov ah,0x07
         mov al,[string+ebx]                ;取得字符串中的一个字符，此时在ax中就完整的包含了一个字符的编码和属性
         mov [es:0xb80a0+ebx*2],ax          ;向显存中传送，使用段超越前缀es，指向整个4G字节的段，演示0~4GB寻址。
         inc ebx                            ;b80a0定位屏幕第二行，ebx*2用来定位后面每个字符的位置
         loop @@4
      
         hlt

;-------------------------------------------------------------------------------
     string           db 's0ke4or92xap3fv8giuzjcy5l1m7hd6bnqtw.'    ;任务是对字符串排序按照字符编码的大小，结果显示在屏幕上
;-------------------------------------------------------------------------------
     pgdt             dw 0               ;先定义一个字，是GDT的边界值，初始化为0，需要再程序中加以填充
                      dd 0x00007e00      ;再定义一个双字，指定GDT的线性物理地址，共6个字节
;-------------------------------------------------------------------------------                             
     times 510-($-$$) db 0
                      db 0x55,0xaa
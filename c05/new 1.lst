     1 00000000 EB1A                    		jmp start
     2                                  
     3 00000002 4C076107620765076C-     mytext  db 'L',0x07,'a',0x07,'b',0x07,'e',0x07,'l',0x07,' ',0x07,"o",0x07,		   'f',0x07,'f',0x07,'s',0x07,'e',0x07,'t',0x07,':',0x07
     3 0000000B 0720076F0766076607-
     3 00000014 7307650774073A07   
     5                                  		   
     6                                  start:
     7 0000001C B8C007                  		mov ax,0x7c0
     8 0000001F 8ED8                    		mov ds,ax				;用7c00代替0000开辟一个新的逻辑段，这样7c00的就没有偏移了
     9                                  		
    10 00000021 B800B8                  		mov ax,0xb800
    11 00000024 8EC0                    		mov es,ax
    12                                  		
    13                                  		;用数据串的传送指令可以传送一串数据
    14 00000026 FC                      		cld						;无操作数指令，CLear Direction flag将FLAGS寄存器的DF标志置0，指示传送是正向的从低地址到高地址，与STD相反
    15 00000027 BE[0200]                		mov si,mytext
    16 0000002A BF0000                  		mov di,0
    17 0000002D B90D00                  		mov cx,(start-mytext)/2	;实际上等于13
    18 00000030 F3A5                    		rep movsw				;movsw只能执行一次，用rep可以反复执行，重复的次数由cx来指定，每次执行前会检查cx，不为0才执行
    19                                  		
    20                                  		;得到标号所代表的汇编地址
    21 00000032 B8[5D00]                		mov ax,number			;标号和数字是等效的，编译后标号可以转化为一个数字，这条指令实际上是把立即数传送到ax寄存器
    22                                  		
    23                                  		;分解各个数位
    24 00000035 89C3                    		mov bx,ax
    25 00000037 B90500                  		mov cx,5				;循环次数
    26 0000003A BE0A00                  		mov si,10				;除数
    27                                  		
    28                                  digit:
    29 0000003D 31D2                    		xor dx,dx
    30 0000003F F7F6                    		div si
    31 00000041 8817                    		mov [bx],dl				;保存数位
    32                                  		;[bx]这种写法意味着访问内存时所使用的偏移地址来自于bx寄存器，就需要bx寄存器保存着偏移地址
    33                                  		;因为之前number代表的地址已经传给了ax，又间接传给了bx，使用的就是bx的内容存放的内存地址
    34                                  		;在8086CPU上，如果要用寄存器来提供偏移地址/移动指针，只能用bx,si,di,bp，不能用其他寄存器
    35 00000043 43                      		inc bx
    36 00000044 E2F7                    		loop digit				;操作码是E2，跟着8位相对偏移量，所以标号的位置不能太远，不然用8位表示不了
    37                                  		;loop的执行过程：将寄存器cx的内容减1，若cx不为零才循环
    38                                  		
    39                                  		;显示各个数位
    40 00000046 BB[5D00]                		mov bx,number
    41 00000049 BE0400                  		mov si,4
    42                                  show:
    43 0000004C 8A00                    		mov al,[bx+si]			;bx是基地址，si是最后一个，取出它
    44 0000004E 0430                    		add al,0x30
    45 00000050 B404                    		mov ah,0x04
    46 00000052 268905                  		mov [es:di],ax
    47 00000055 83C702                  		add di,2
    48 00000058 4E                      		dec si
    49 00000059 79F1                    		jns show				;如果标志寄存器的符号位置是0则转移至标志位置执行
    50                                  		;sf是flags寄存器的第7位signflag,0表示正数，1表示复数，由于si的初始值是4，第1次执行，si变3，都能将sf位清0
    51                                  		;4次减完，si变成16个1，于是要将sf位置1
    52                                  		
    53 0000005B EBFE                    		jmp $					;让jmp指令不断执行自身
    54                                  		
    55 0000005D 0000000000              number	db 0, 0, 0, 0, 0
    56                                  		
    57 00000062 00<rep 19Ch>            		times 510-($-$$) db 0	;一个$代表当前行的汇编地址，两个$$代表当前程序段的汇编地址/程序起始的汇编地址
    58 000001FE 55AA                    		db 0x55, 0xaa
    59                                  		
    60                                  		

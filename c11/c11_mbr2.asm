         ;代码清单11-1
         ;文件名：c11_mbr2.asm
         ;文件说明：硬盘主引导扇区代码 
         ;创建日期：2020-6-22 18:00
      
         ;计算GDT所在的逻辑段地址 
         mov ax,[cs:gdt_base+0x7c00]        ;低16位，这是以cs=0为起始的段，所以ax里存的就是物理地址
         mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位，gdt_base其实是一个偏移量
         mov bx,16        
         div bx                             ;除以16就得到了逻辑段地址和偏移地址
         mov ds,ax                          ;令ds指向该段逻辑段地址以进行操作
         mov bx,dx                          ;令bx指向段内起始偏移地址 
      
         ;创建0#描述符，它是空描述符，这是处理器的要求
         mov dword [bx+0x00],0x00
         mov dword [bx+0x04],0x00

         ;创建#1描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区） 
         mov dword [bx+0x08],0x8000ffff     
         mov dword [bx+0x0c],0x0040920b     ;段描述符里有很多信息，这里的段基地址是000b8000

         ;创建#2描述符，保护模式下的代码段描述符
         mov dword [bx+0x10],0x7c0001ff     ;低双字
         mov dword [bx+0x14],0x00409800     ;高双字，段描述符里有很多信息，这里的段基地址是00007c00正好是主引导程序的起始地址
         
         ;初始化描述符表寄存器GDTR
         mov word [cs: gdt_size+0x7c00],23  ;描述符表的界限（3个描述符总字节是24，总字节数减一）   
                                             
         lgdt [cs: gdt_size+0x7c00]
      
         in al,0x92                         ;南桥芯片内的端口 
         or al,0000_0010B
         out 0x92,al                        ;打开A20

         cli                                ;保护模式下中断机制尚未建立，应禁止中断 
                                            
         mov eax,cr0
         or eax,1
         mov cr0,eax                        ;设置PE位
         
         ;以下进入保护模式... ...有不同
         jmp 0000000000010_0_00B:flush      ;直接绝对远转移指令，在实模式下vs保护模式下是不同的
                                            ;这之前是按照16位尺寸编译的，这之后是按照32位尺寸编译的，虽然不匹配，但是前面进流水线已经执行过了
         bits 32                            ;由此取到了代码段描述符，而它的D位是1，因此，后面flush以下就都变成32位了。因此jmp后面用了bits32
         
flush:                                      ;从flush这里往下执行，处理器的默认尺寸就编程32位的了。这就要求后面的指令必须按照32位尺寸编译
         mov cx,0000000000001_0_00B         ;加载数据段选择子(0x01)到段选择器，发现要选的是1号描述符，就是第2个，里面存的段基地址是000b8000
         mov ds,cx                          ;让段选择器ds指向显存，现在ds描述符高速缓存器里里保存的基地址是b8000
         ;以下在屏幕上显示"Protect mode OK." flush后文本这段，在执行bits 32 之前都已经进了流水线，译码按照16位译的是错的，
         ;好在在jmp之后会清空流水线,刚刚的结果会被清理，处理器会串行化执行，处理器开始用32位操作尺寸重新填充流水线
         mov byte [0x00],'P'  
         mov byte [0x02],'r'
         mov byte [0x04],'o'
         mov byte [0x06],'t'
         mov byte [0x08],'e'
         mov byte [0x0a],'c'
         mov byte [0x0c],'t'
         mov byte [0x0e],' '
         mov byte [0x10],'m'
         mov byte [0x12],'o'
         mov byte [0x14],'d'
         mov byte [0x16],'e'
         mov byte [0x18],' '
         mov byte [0x1a],'O'
         mov byte [0x1c],'K'

         hlt                                ;已经禁止中断，处理器将不会被唤醒 

;-------------------------------------------------------------------------------
     
         gdt_size         dw 0              ;保存GDT的界限值
         gdt_base         dd 0x00007e00     ;GDT的物理地址 
                             
         times 510-($-$$) db 0
                          db 0x55,0xaa
     1                                           ;代码清单8-2
     2                                           ;文件名：c08.asm
     3                                           ;文件说明：用户程序 
     4                                           ;创建日期：2011-5-5 18:17
     5                                           
     6                                  ;===============================================================================
     7                                  SECTION header vstart=0                     ;定义用户程序头部段 
     8 00000000 [00000000]                  program_length  dd program_end          ;程序总长度[0x00]
     9                                      
    10                                      ;用户程序入口点
    11 00000004 [A200]                      code_entry      dw start                ;偏移地址[0x04]
    12 00000006 [00000000]                                  dd section.code_1.start ;段地址[0x06] 
    13                                      
    14 0000000A 0500                        realloc_tbl_len dw (header_end-code_1_segment)/4
    15                                                                              ;段重定位表项个数[0x0a]
    16                                      
    17                                      ;段重定位表           
    18 0000000C [00000000]                  code_1_segment  dd section.code_1.start ;[0x0c]
    19 00000010 [00000000]                  code_2_segment  dd section.code_2.start ;[0x10]
    20 00000014 [00000000]                  data_1_segment  dd section.data_1.start ;[0x14]
    21 00000018 [00000000]                  data_2_segment  dd section.data_2.start ;[0x18]
    22 0000001C [00000000]                  stack_segment   dd section.stack.start  ;[0x1c]
    23                                      
    24                                      header_end:                
    25                                      
    26                                  ;===============================================================================
    27                                  SECTION code_1 align=16 vstart=0         ;定义代码段1（16字节对齐） 
    28                                  put_string:                              ;显示串(0结尾)，这个字符串必须时0结尾的
    29                                                                           ;输入：DS:BX=串地址
    30 00000000 8A0F                             mov cl,[bx]                     ;但是计算结果回影响到标志寄存器中的某些位，ZF是0则取得的是空字符0
    31 00000002 08C9                             or cl,cl                        ;cl=0 ?用cmp cl,0时最直观的，但这里是一个数和他自己做或运算，结果还是它自己
    32 00000004 7406                             jz .exit                        ;是的，返回主程序 
    33 00000006 E80400                           call put_char
    34 00000009 43                               inc bx                          ;下一个字符 
    35 0000000A EBF4                             jmp put_string
    36                                  
    37                                     .exit:
    38 0000000C C3                               ret
    39                                  
    40                                  ;-------------------------------------------------------------------------------
    41                                  put_char:                                ;显示一个字符
    42                                                                           ;输入：cl=字符ascii
    43 0000000D 50                               push ax
    44 0000000E 53                               push bx
    45 0000000F 51                               push cx
    46 00000010 52                               push dx
    47 00000011 1E                               push ds
    48 00000012 06                               push es
    49                                  
    50                                           ;以下取当前光标位置
    51 00000013 BAD403                           mov dx,0x3d4                    ;通过索引端口3d4告诉显卡，现在要操作0e号寄存器
    52 00000016 B00E                             mov al,0x0e
    53 00000018 EE                               out dx,al
    54 00000019 BAD503                           mov dx,0x3d5                    ;通过数据端口3d5从0e号寄存器读出一个字节的数据
    55 0000001C EC                               in al,dx
    56 0000001D 88C4                             mov ah,al                       ;把al中的传送到ah中，这时光标位置的高8位
    57                                  
    58 0000001F BAD403                           mov dx,0x3d4
    59 00000022 B00F                             mov al,0x0f
    60 00000024 EE                               out dx,al
    61 00000025 BAD503                           mov dx,0x3d5
    62 00000028 EC                               in al,dx                        ;低8位  
    63 00000029 89C3                             mov bx,ax                       ;BX=代表光标位置的16位数，把ax传到bx中临时保存
    64                                           ;一旦知道了光标的位置，就意味着字符在屏幕上的显示位置确定了，字符是通过cl传入的，cl中是字符的编码
    65 0000002B 80F90D                           cmp cl,0x0d                     ;回车符？
    66 0000002E 750C                             jnz .put_0a                     ;不是。看看是不是换行等字符 
    67 00000030 89D8                             mov ax,bx                       ;此句略显多余，但去掉后还得改书，麻烦 
    68 00000032 B350                             mov bl,80                       
    69 00000034 F6F3                             div bl
    70 00000036 F6E3                             mul bl
    71 00000038 89C3                             mov bx,ax
    72 0000003A EB47                             jmp .set_cursor
    73                                           ;在标准VGA文本模式下，每屏是25行，每行是80列，80个字符，0-24，0-79
    74                                   .put_0a:
    75 0000003C 80F90A                           cmp cl,0x0a                     ;换行符？
    76 0000003F 7505                             jnz .put_other                  ;不是，那就正常显示字符 
    77 00000041 83C350                           add bx,80
    78 00000044 EB0F                             jmp .roll_screen
    79                                  
    80                                   .put_other:                             ;正常显示字符
    81 00000046 B800B8                           mov ax,0xb800
    82 00000049 8EC0                             mov es,ax
    83 0000004B D1E3                             shl bx,1                        ;根据光标位置数值得到字符的段内偏移地址，1个字符对应显存里的2个字节但对应着屏幕上1个光标
    84 0000004D 26880F                           mov [es:bx],cl                  ;将光标位置乘以2就得到了在显存内部的偏移地址，逻辑左移
    85                                  
    86                                           ;以下将光标位置推进一个字符
    87 00000050 D1EB                             shr bx,1
    88 00000052 83C301                           add bx,1
    89                                  
    90                                   .roll_screen:
    91 00000055 81FBD007                         cmp bx,2000                     ;光标超出屏幕？滚屏
    92 00000059 7C28                             jl .set_cursor                  ;不越界，就设置光标
    93                                           ;以下就是滚屏操作，是在显存里批量传输数据
    94 0000005B 53                               push bx                         ;原书出错，修改：先将bx位置的数据压栈保存，因为后面的批量数据传送要用道bx
    95 0000005C B800B8                           mov ax,0xb800
    96 0000005F 8ED8                             mov ds,ax
    97 00000061 8EC0                             mov es,ax
    98 00000063 FC                               cld                             ;设置方向标志正向传送
    99 00000064 BEA000                           mov si,0xa0                     ;设置原区域的起始偏移地址0xa0，传到变址寄存器si中
   100 00000067 BF0000                           mov di,0x00                     ;再设置目标区域的偏移地址
   101 0000006A B98007                           mov cx,1920
   102 0000006D F3A5                             rep movsw                       ;批量传送
   103                                           
   104 0000006F BB000F                           mov bx,3840                     ;清除屏幕最底一行，最后一行最左边的字符在显存中的偏移地址是3840，写入80个空格
   105 00000072 B95000                           mov cx,80
   106                                   .cls:
   107 00000075 26C7072007                       mov word[es:bx],0x0720          ;07是属性，20是空格的十六进制编码
   108 0000007A 83C302                           add bx,2                        ;指向下一个空格
   109 0000007D E2F6                             loop .cls
   110                                  
   111                                           ;mov bx,1920                    ;为了修改原书的逻辑问题，删除此行，新增下2行
   112 0000007F 5B                               pop bx                          ;如果滚屏是光标超出了屏幕的右下角引起的，最后一个字符1999的光标是2000，滚屏后移到最后一行的行首也需要减80
   113 00000080 83EB50                           sub bx,80                       ;如果滚屏是换行引起的，那么光标应该还在最后一行的某个位置，而前面已经加上80了，所以减掉
   114                                  
   115                                   .set_cursor:
   116 00000083 BAD403                           mov dx,0x3d4
   117 00000086 B00E                             mov al,0x0e
   118 00000088 EE                               out dx,al
   119 00000089 BAD503                           mov dx,0x3d5
   120 0000008C 88F8                             mov al,bh                       ;光标位置的数值保存在寄存器bx，但写端口只能用寄存器al
   121 0000008E EE                               out dx,al                       ;显示光标位置的高8位
   122 0000008F BAD403                           mov dx,0x3d4                    ;通过3d4端口指定寄存器0f
   123 00000092 B00F                             mov al,0x0f
   124 00000094 EE                               out dx,al
   125 00000095 BAD503                           mov dx,0x3d5                    ;通过3d5端口向寄存器0f写入光标位置的低8位
   126 00000098 88D8                             mov al,bl
   127 0000009A EE                               out dx,al
   128                                  
   129 0000009B 07                               pop es
   130 0000009C 1F                               pop ds
   131 0000009D 5A                               pop dx
   132 0000009E 59                               pop cx
   133 0000009F 5B                               pop bx
   134 000000A0 58                               pop ax
   135                                  
   136 000000A1 C3                               ret
   137                                  
   138                                  ;-------------------------------------------------------------------------------
   139                                    start:
   140                                           ;初始执行时，DS和ES指向用户程序头部段
   141 000000A2 A1[1C00]                         mov ax,[stack_segment]           ;设置到用户程序自己的堆栈 
   142 000000A5 8ED0                             mov ss,ax
   143 000000A7 BC[0001]                         mov sp,stack_end
   144                                           
   145 000000AA A1[1400]                         mov ax,[data_1_segment]          ;设置到用户程序自己的数据段，此时只有es还指向头部段
   146 000000AD 8ED8                             mov ds,ax
   147                                  
   148 000000AF BB[0000]                         mov bx,msg0
   149 000000B2 E84BFF                           call put_string                  ;显示第一段信息 
   150                                  
   151 000000B5 26FF36[1000]                     push word [es:code_2_segment]    ;es此时还指向头部段，从重定位表那里取得code2的逻辑段地址，压栈
   152 000000BA B8[0000]                         mov ax,begin                     ;还要压入目标位置的偏移地址，就是begin在编译阶段的汇编地址，因为又vstart=0，所以从段首开始计算，8086无法传入一个立即数，所以通过ax
   153 000000BD 50                               push ax                          ;可以直接push begin,80386+
   154                                           
   155 000000BE CB                               retf                             ;转移到代码段2执行 return far模拟原返回以实现段间转移，与push code2结合使用，会转移到code2去执行
   156                                           
   157                                    continue:
   158 000000BF 26A1[1800]                       mov ax,[es:data_2_segment]       ;段寄存器DS切换到数据段2 ，ds又变了，es仍不变，ds取得了重定位表中data2的逻辑段地址
   159 000000C3 8ED8                             mov ds,ax
   160                                           
   161 000000C5 BB[0000]                         mov bx,msg1
   162 000000C8 E835FF                           call put_string                  ;显示第二段信息 
   163                                  
   164 000000CB EBFE                             jmp $                            ;通常用户程序执行完毕后，应该重新将控制返回到加载器，这样加载器可以加载其他程序，但这里的mbr加载器不提供这个功能
   165                                  
   166                                  ;===============================================================================
   167                                  SECTION code_2 align=16 vstart=0          ;定义代码段2（16字节对齐）
   168                                  
   169                                    begin:
   170 00000000 26FF36[0C00]                     push word [es:code_1_segment]    ;用retf就是假装从过程返回，假装主程序是子程序。es仍是是指向header的，所以压栈的就是重定位表的逻辑段地址
   171 00000005 B8[BF00]                         mov ax,continue
   172 00000008 50                               push ax                          ;可以直接push continue,80386+
   173                                           
   174 00000009 CB                               retf                             ;转移到代码段1接着执行 
   175                                           
   176                                  ;===============================================================================
   177                                  SECTION data_1 align=16 vstart=0                                ;因为vstart=0，所以msg0的汇编地址是0，在程序运行时它的汇编地址也是它的段内偏移地址
   178                                  
   179 00000000 202054686973206973-         msg0 db '  This is NASM - the famous Netwide Assembler. '
   179 00000009 204E41534D202D2074-
   179 00000012 68652066616D6F7573-
   179 0000001B 204E65747769646520-
   179 00000024 417373656D626C6572-
   179 0000002D 2E20               
   180 0000002F 4261636B2061742053-              db 'Back at SourceForge and in intensive development! '
   180 00000038 6F75726365466F7267-
   180 00000041 6520616E6420696E20-
   180 0000004A 696E74656E73697665-
   180 00000053 20646576656C6F706D-
   180 0000005C 656E742120         
   181 00000061 476574207468652063-              db 'Get the current versions from http://www.nasm.us/.'
   181 0000006A 757272656E74207665-
   181 00000073 7273696F6E73206672-
   181 0000007C 6F6D20687474703A2F-
   181 00000085 2F7777772E6E61736D-
   181 0000008E 2E75732F2E         
   182 00000093 0D0A0D0A                         db 0x0d,0x0a,0x0d,0x0a                                 ;0x0d是回车，0x0a是换行符，不是图形字符，无法显示，只能通过编码来引用            
   183 00000097 20204578616D706C65-              db '  Example code for calculate 1+2+...+1000:',0x0d,0x0a,0x0d,0x0a
   183 000000A0 20636F646520666F72-
   183 000000A9 2063616C63756C6174-
   183 000000B2 6520312B322B2E2E2E-
   183 000000BB 2B313030303A0D0A0D-
   183 000000C4 0A                 
   184 000000C5 2020202020786F7220-              db '     xor dx,dx',0x0d,0x0a
   184 000000CE 64782C64780D0A     
   185 000000D5 2020202020786F7220-              db '     xor ax,ax',0x0d,0x0a
   185 000000DE 61782C61780D0A     
   186 000000E5 2020202020786F7220-              db '     xor cx,cx',0x0d,0x0a
   186 000000EE 63782C63780D0A     
   187 000000F5 202040403A0D0A                   db '  @@:',0x0d,0x0a
   188 000000FC 2020202020696E6320-              db '     inc cx',0x0d,0x0a
   188 00000105 63780D0A           
   189 00000109 202020202061646420-              db '     add ax,cx',0x0d,0x0a
   189 00000112 61782C63780D0A     
   190 00000119 202020202061646320-              db '     adc dx,0',0x0d,0x0a
   190 00000122 64782C300D0A       
   191 00000128 2020202020696E6320-              db '     inc cx',0x0d,0x0a
   191 00000131 63780D0A           
   192 00000135 2020202020636D7020-              db '     cmp cx,1000',0x0d,0x0a
   192 0000013E 63782C313030300D0A 
   193 00000147 20202020206A6C6520-              db '     jle @@',0x0d,0x0a
   193 00000150 40400D0A           
   194 00000154 20202020202E2E2E20-              db '     ... ...(Some other codes)',0x0d,0x0a,0x0d,0x0a
   194 0000015D 2E2E2E28536F6D6520-
   194 00000166 6F7468657220636F64-
   194 0000016F 6573290D0A0D0A     
   195 00000176 00                               db 0                                                   ;0用来标志字符串的结束，这种被称为0终止字符串
   196                                  
   197                                  ;===============================================================================
   198                                  SECTION data_2 align=16 vstart=0
   199                                  
   200 00000000 20205468652061626F-         msg1 db '  The above contents is written by LeeChung. ' ;没有回车换行，在一行显示，光标最后在6的后面
   200 00000009 766520636F6E74656E-
   200 00000012 747320697320777269-
   200 0000001B 7474656E206279204C-
   200 00000024 65654368756E672E20 
   201 0000002D 323031312D30352D30-              db '2011-05-06'
   201 00000036 36                 
   202 00000037 00                               db 0
   203                                  
   204                                  ;===============================================================================
   205                                  SECTION stack align=16 vstart=0
   206                                             
   207 00000000 <res 100h>                       resb 256
   207          ******************       warning: uninitialized space declared in stack section: zeroing [-w+zeroing]
   208                                  
   209                                  stack_end:  
   210                                  
   211                                  ;===============================================================================
   212                                  SECTION trail align=16                      ;主要是让标号program_end有一个16进制对齐的汇编地址    
   213                                  program_end:                                ;因为没有vstart=0子句，所以它的汇编地址就是程序的总长度，以字节计

     1                                           ;代码清单8-1
     2                                           ;文件名：c08_mbr.asm
     3                                           ;文件说明：硬盘主引导扇区代码（加载程序） 
     4                                           ;创建日期：2011-5-5 18:17
     5                                           ;用户程序在硬盘上的位置必须从逻辑扇区号100开始，加载器也从这个位置加载用户程序
     6                                           app_lba_start equ 100           ;声明常数（用户程序起始逻辑扇区号）
     7                                                                           ;常数的声明不会占用汇编地址
     8                                                                      
     9                                  SECTION mbr align=16 vstart=0x7c00                                     
    10                                  
    11                                           ;设置堆栈段和栈指针 
    12 00000000 B80000                           mov ax,0      
    13 00000003 8ED0                             mov ss,ax
    14 00000005 89C4                             mov sp,ax
    15                                           
    16 00000007 2EA1[C700]                       mov ax,[cs:phy_base]            ;计算用于加载用户程序的逻辑段地址 
    17 0000000B 2E8B16[C900]                     mov dx,[cs:phy_base+0x02]
    18 00000010 BB1000                           mov bx,16        
    19 00000013 F7F3                             div bx                          ;最后的商在ax中，这个商就是16位的段地址
    20 00000015 8ED8                             mov ds,ax                       ;令DS和ES指向该段以进行操作
    21 00000017 8EC0                             mov es,ax                        
    22                                      
    23                                           ;以下读取程序的起始部分 
    24 00000019 31FF                             xor di,di
    25 0000001B BE6400                           mov si,app_lba_start            ;程序在硬盘上的起始逻辑扇区号 
    26 0000001E 31DB                             xor bx,bx                       ;加载到DS:0x0000处 
    27 00000020 E85100                           call read_hard_disk_0           ;处理器在进入子程序之前，先将指令指针寄存器ip的内容压栈，就是下一行
    28                                        
    29                                           ;以下判断整个程序有多大
    30 00000023 8B160200                         mov dx,[2]                      ;不要把dx写成ds，用户程序总长度的高16位取出 
    31 00000027 A10000                           mov ax,[0]                      ;用户程序总长度的低16位
    32                                                                           ;因为ds是指向用户程序头部段的，所以上2条指令执行时是ds左移四位+0或2
    33 0000002A BB0002                           mov bx,512                      ;512字节每扇区
    34 0000002D F7F3                             div bx
    35 0000002F 83FA00                           cmp dx,0
    36 00000032 7501                             jnz @1                          ;未除尽，因此结果比实际扇区数少1 
    37 00000034 48                               dec ax                          ;已经读了一个扇区，扇区总数减1 
    38                                     @1:
    39 00000035 83F800                           cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 
    40 00000038 7413                             jz direct
    41                                           
    42                                           ;读取剩余的扇区，但最多也就只能读64k，ffff字节的地址，所以要临时改变一下ds。读完再恢复
    43 0000003A 1E                               push ds                         ;以下要用到并改变DS寄存器 
    44                                  
    45 0000003B 89C1                             mov cx,ax                       ;循环次数（剩余扇区数）要想循环，必须先设置cx
    46                                     @2:
    47 0000003D 8CD8                             mov ax,ds
    48 0000003F 83C020                           add ax,0x20                     ;得到下一个以512字节为边界的段地址
    49 00000042 8ED8                             mov ds,ax  
    50                                                                
    51 00000044 31DB                             xor bx,bx                       ;每次读时，偏移地址始终为0x0000 
    52 00000046 46                               inc si                          ;下一个逻辑扇区 
    53 00000047 E82A00                           call read_hard_disk_0
    54 0000004A E2F1                             loop @2                         ;循环读，直到读完整个功能程序 
    55                                  
    56 0000004C 1F                               pop ds                          ;恢复数据段基址到用户程序头部段 
    57                                        
    58                                           ;计算入口点代码段基址 
    59                                     direct:
    60 0000004D 8B160800                         mov dx,[0x08]                   ;取出代码段地址的高16位并传送到dx
    61 00000051 A10600                           mov ax,[0x06]                   ;取出低16位
    62 00000054 E85700                           call calc_segment_base          ;一旦获得了入口点代码段的汇编地址，下面就是根据整个程序加载的起始物理地址来计算出该段的逻辑段地址，调用子程序来计算
    63 00000057 A30600                           mov [0x06],ax                   ;获得了16位的代码段逻辑段地址，回填修正后的入口点代码段基址，覆盖掉原来的代码段汇编地址，这就完成了入口点的重定位
    64                                        
    65                                           ;开始处理段重定位表
    66 0000005A 8B0E0A00                         mov cx,[0x0a]                   ;需要重定位的项目数量
    67 0000005E BB0C00                           mov bx,0x0c                     ;重定位表首地址
    68                                            
    69                                   realloc:                                ;bx指向每一个表项，表项的内容是段的汇编地址，双字长度
    70 00000061 8B5702                           mov dx,[bx+0x02]                ;取得32位汇编地址的高16位 
    71 00000064 8B07                             mov ax,[bx]                     ;取得32位汇编地址的低16位
    72 00000066 E84500                           call calc_segment_base          ;用段的汇编地址生成逻辑段地址，返回给ax
    73 00000069 8907                             mov [bx],ax                     ;用生成的逻辑段地址回填覆盖给这个段的汇编地址基址，bx是汇编地址所在的偏移地址
    74 0000006B 83C304                           add bx,4                        ;下一个重定位项（每项占4个字节） 
    75 0000006E E2F1                             loop realloc 
    76                                        
    77 00000070 FF2E0400                         jmp far [0x04]                  ;间接绝对语言转移指令，转移到用户程序  
    78                                   
    79                                  ;-------------------------------------------------------------------------------
    80                                  read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区
    81                                                                           ;输入：DI:SI=起始逻辑扇区号
    82                                                                           ;      DS:BX=目标缓冲区地址
    83                                           ;在过程调用之前，调用者可能正在使用某些寄存器，在进入子程序之后，
    84                                           ;应该保证不破坏这些寄存器的内容，为了使程序在过程调用的前后不失连续性，
    85                                           ;在过程开头，应该将本过程用到的寄存器临时压栈，并在返回到调用点之前出栈恢复
    86 00000074 50                               push ax
    87 00000075 53                               push bx
    88 00000076 51                               push cx
    89 00000077 52                               push dx
    90                                        
    91 00000078 BAF201                           mov dx,0x1f2
    92 0000007B B001                             mov al,1
    93 0000007D EE                               out dx,al                       ;读取的扇区数
    94                                  
    95 0000007E 42                               inc dx                          ;0x1f3
    96 0000007F 89F0                             mov ax,si
    97 00000081 EE                               out dx,al                       ;LBA地址7~0
    98                                  
    99 00000082 42                               inc dx                          ;0x1f4
   100 00000083 88E0                             mov al,ah
   101 00000085 EE                               out dx,al                       ;LBA地址15~8
   102                                  
   103 00000086 42                               inc dx                          ;0x1f5
   104 00000087 89F8                             mov ax,di
   105 00000089 EE                               out dx,al                       ;LBA地址23~16
   106                                  
   107 0000008A 42                               inc dx                          ;0x1f6
   108 0000008B B0E0                             mov al,0xe0                     ;LBA28模式，主盘
   109 0000008D 08E0                             or al,ah                        ;LBA地址27~24
   110 0000008F EE                               out dx,al
   111                                  
   112 00000090 42                               inc dx                          ;0x1f7
   113 00000091 B020                             mov al,0x20                     ;读命令
   114 00000093 EE                               out dx,al
   115                                  
   116                                    .waits:
   117 00000094 EC                               in al,dx
   118 00000095 2488                             and al,0x88
   119 00000097 3C08                             cmp al,0x08
   120 00000099 75F9                             jnz .waits                      ;不忙，且硬盘已准备好数据传输 
   121                                  
   122 0000009B B90001                           mov cx,256                      ;总共要读取的字数
   123 0000009E BAF001                           mov dx,0x1f0
   124                                    .readw:
   125 000000A1 ED                               in ax,dx
   126 000000A2 8907                             mov [bx],ax
   127 000000A4 83C302                           add bx,2
   128 000000A7 E2F8                             loop .readw
   129                                  
   130 000000A9 5A                               pop dx
   131 000000AA 59                               pop cx
   132 000000AB 5B                               pop bx
   133 000000AC 58                               pop ax
   134                                        
   135 000000AD C3                               ret                             ;需要一条明确return指令让过程从哪里来回哪里去
   136                                  
   137                                  ;-------------------------------------------------------------------------------
   138                                  calc_segment_base:                       ;计算16位段地址，要求在调用时必须先输入一个32位的汇编地址并分成2部分
   139                                                                           ;输入：DX:AX=32位物理地址
   140                                                                           ;返回：AX=16位段基地址 
   141 000000AE 52                               push dx                         
   142                                           
   143 000000AF 2E0306[C700]                     add ax,[cs:phy_base]            ;如果有进位，cf标志是1
   144 000000B4 2E1316[C900]                     adc dx,[cs:phy_base+0x02]       ;8086无法做32位的加法，需要2个寄存器做2个16位的加法，adc是带进位的加法指令
   145 000000B9 C1E804                           shr ax,4                        ;用逻辑右移指令shr将ax整体右移4次
   146 000000BC C1CA04                           ror dx,4                        ;用循环右移指令将dx的内容右移4次
   147 000000BF 81E200F0                         and dx,0xf000                   ;先用dx与f000逻辑与，确保dx低12位全是0，虽然多余，但当phybase指定的不对时就有意义了
   148 000000C3 09D0                             or ax,dx                        ;将2部分逻辑或，合成一个完整的16位逻辑段地址并回送到ax
   149                                           
   150 000000C5 5A                               pop dx
   151                                           
   152 000000C6 C3                               ret
   153                                  
   154                                  ;-------------------------------------------------------------------------------
   155 000000C7 00000100                         phy_base dd 0x10000             ;用户程序被加载的物理起始地址
   156                                           ;开辟了一个16字节的空间来存储是为了方便，可以改为其他地方，只要最后一位是0能够对齐就可以
   157                                           
   158 000000CB 00<rep 133h>             times 510-($-$$) db 0
   159 000001FE 55AA                                      db 0x55,0xaa

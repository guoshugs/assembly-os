     1                                           ;代码清单7-1
     2                                           ;文件名：c07_mbr.asm
     3                                           ;文件说明：硬盘主引导扇区代码
     4                                           ;创建日期：2011-4-13 18:02
     5                                           
     6 00000000 E90E00                           jmp near start
     7                                  	
     8 00000003 312B322B332B2E2E2E-      message db '1+2+3+...+100='	;message的汇编地址是0003
     8 0000000C 2B3130303D         
     9                                  		;message在编译时计算的汇编地址0003 = 
    10                                  		;程序加载到内存之后的段内偏移地址，任何使用这个标号来访问内存的指令都不会产生问题
    11                                  		;即，我在下面写程序时可以随意直接使用message当访问地址，而不用再加7c00当地址了，不然是必须要+7c00的
    12                                          
    13                                   start:
    14 00000011 B8C007                           mov ax,0x7c0			;start在0011位置
    15 00000014 8ED8                             mov ds,ax				;7c00传入数据段ds，设置数据段的段基地址
    16                                  
    17 00000016 B800B8                           mov ax,0xb800          ;设置附加段基址到显示缓冲区
    18 00000019 8EC0                             mov es,ax
    19                                  
    20                                           ;以下显示字符串 
    21 0000001B BE[0300]                         mov si,message         ;0003颠倒0300传给了si
    22 0000001E BF0000                           mov di,0
    23 00000021 B90E00                           mov cx,start-message	;由于商是压入栈中的，将来还要弹出，必须记住有多少个数
    24                                   showmsg:
    25 00000024 8A04                             mov al,[si]			;把si所在地址取出一位
    26 00000026 268805                           mov [es:di],al			;把它存入显存
    27 00000029 47                               inc di					;偏移显存
    28 0000002A 26C60507                         mov byte [es:di],0x07	;存入属性
    29 0000002E 47                               inc di					;数据段偏移1
    30 0000002F 46                               inc si					;
    31 00000030 E2F2                             loop showmsg
    32                                  
    33                                           ;以下计算1到100的和 
    34 00000032 31C0                             xor ax,ax
    35 00000034 B90100                           mov cx,1
    36                                   summate:
    37 00000037 01C8                             add ax,cx				;结果5050已经放入ax里了
    38 00000039 41                               inc cx
    39 0000003A 83F964                           cmp cx,100
    40 0000003D 7EF8                             jle summate
    41                                  
    42                                           ;以下分解累加和5050的每个数位 
    43 0000003F 31C9                             xor cx,cx              ;设置堆栈段的段基地址
    44 00000041 8ED1                             mov ss,cx
    45 00000043 89CC                             mov sp,cx
    46                                  
    47 00000045 BB0A00                           mov bx,10
    48 00000048 31C9                             xor cx,cx
    49                                   decompo:
    50 0000004A 41                               inc cx
    51 0000004B 31D2                             xor dx,dx
    52 0000004D F7F3                             div bx					;数位的分解还是要用到除法算法
    53 0000004F 80CA30                           or dl,0x30
    54                                  		 ;应该用add，但因除数是10所以分解出来的数位总是小于10，且0x30的最后是0，二进制是4个0，因此可以用or
    55 00000052 52                               push dx				;16位的8086处理器上，压栈和出栈都只能是16位，所以要把dx一块用了
    56                                  		 ;入栈过程：先把sp减去处理器的字长，8086上是2，然后再入栈
    57 00000053 83F800                           cmp ax,0				;每次除法后都判断，商是0就提前结束
    58 00000056 75F2                             jne decompo
    59                                  
    60                                           ;以下显示各个数位 
    61                                   shownum:
    62 00000058 5A                               pop dx
    63 00000059 268815                           mov [es:di],dl			;前面显示字符串的时候就是用di提供偏移地址，因此此时di正好指向字符串尾
    64 0000005C 47                               inc di
    65 0000005D 26C60507                         mov byte [es:di],0x07
    66 00000061 47                               inc di
    67 00000062 E2F4                             loop shownum
    68                                         
    69 00000064 E9FDFF                           jmp near $ 
    70                                         
    71                                  
    72 00000067 00<rep 197h>            times 510-($-$$) db 0
    73 000001FE 55AA                                     db 0x55,0xaa
